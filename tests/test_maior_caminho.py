
# Generated by CodiumAI
from src.types.graph import Graph
from src.functions.use_cases import gera_grafo, maior_caminho


import unittest

"""
Code Analysis

Objective:
The objective of the function is to find the vertex with the highest distance from a given starting vertex in a graph, using breadth-first search algorithm.

Inputs:
- graph: a Graph object representing the graph to be searched
- v1: a string representing the starting vertex

Flow:
1. Initialize a queue and a set of visited vertices.
2. Enqueue the starting vertex with distance 0 and mark it as visited.
3. Create an empty list to store the distances of each vertex from the starting vertex.
4. While the queue is not empty, dequeue a vertex and its distance from the queue.
5. Append the vertex and its distance to the distances list.
6. For each neighbor of the dequeued vertex, if it has not been visited, enqueue it with a distance one greater than the dequeued vertex and mark it as visited.
7. Return the vertex with the highest distance from the starting vertex.

Outputs:
- A string representing the vertex with the highest distance from the starting vertex.

Additional aspects:
- The function uses breadth-first search algorithm to traverse the graph and find the vertex with the highest distance from the starting vertex.
- The function assumes that the graph is connected, otherwise it may not find the vertex with the highest distance from the starting vertex.
"""


class TestMaiorCaminho(unittest.TestCase):
    # Tests that the function returns an empty string when the graph has only one vertex and no edges
    def test_empty_graph(self):
        graph = Graph()
        graph.add_vertex('Raiz')
        self.assertEqual(maior_caminho(graph, 'Raiz'), 'Raiz')

    # Tests that the function returns the correct vertex label when the longest path is from the root to a leaf
    def test_longest_path_to_leaf(self):
        sequ = [1, 2, 3]
        expected = '3-2-1'
        self.assertEqual(maior_caminho(gera_grafo(sequ), 'Raiz'), expected)

    # Tests that the function returns the correct vertex label when the longest path is from the root to an internal node
    def test_longest_path_to_internal_node(self):
        sequ = [1, 3, 2]
        expected = '3-1'
        self.assertEqual(maior_caminho(gera_grafo(sequ), 'Raiz'), expected)

    # Tests that the function returns the correct vertex label when the longest path is from an internal node to a leaf
    def test_longest_path_from_internal_node_to_leaf(self):
        sequ = [3, 1, 2]
        expected = '2-1'
        self.assertEqual(maior_caminho(gera_grafo(sequ), 'Raiz'), expected)

    # Tests that the function returns the correct vertex label when there are multiple paths with the same maximum length
    def test_multiple_paths_with_same_maximum_length(self):
        sequ = [1, 3, 2, 4, 5]
        expected = '5-4-3-1'
        self.assertEqual(maior_caminho(gera_grafo(sequ), 'Raiz'), expected)

    # Tests that the function raises an exception when the graph has a cycle
    def test_graph_with_cycle(self):
        sequ = [1, 2, 3]
        graph = gera_grafo(sequ)
        graph.add_edge(('3', '1'))
        with self.assertRaises(ValueError):
            maior_caminho(graph, 'Raiz')
